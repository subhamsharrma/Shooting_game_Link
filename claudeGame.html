<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Shooter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: white;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: radial-gradient(circle, #001122, #000000);
        }
        
        #gameContainer {
            position: relative;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px #00ffff;
        }
        
        canvas {
            background: #000011;
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 18px;
            z-index: 10;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 2px solid #ff0000;
            border-radius: 10px;
            display: none;
            z-index: 20;
        }
        
        button {
            background: #00ffff;
            border: none;
            color: black;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
            border-radius: 5px;
        }
        
        button:hover {
            background: #00dddd;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Level: <span id="level">1</span></div>
        </div>
        <div id="gameOver">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button onclick="game.restart()">Play Again</button>
        </div>
        <div id="instructions">
            Arrow keys to move • Spacebar to shoot • Collect power-ups!
        </div>
    </div>

    <script>
        // TypeScript-style game code
        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
            
            add(other) {
                return new Vector2(this.x + other.x, this.y + other.y);
            }
            
            multiply(scalar) {
                return new Vector2(this.x * scalar, this.y * scalar);
            }
        }
        
        class GameObject {
            constructor(x, y, width, height) {
                this.position = new Vector2(x, y);
                this.velocity = new Vector2(0, 0);
                this.width = width;
                this.height = height;
                this.active = true;
            }
            
            update(deltaTime) {
                this.position = this.position.add(this.velocity.multiply(deltaTime));
            }
            
            draw(ctx) {
                // Override in subclasses
            }
            
            getBounds() {
                return {
                    left: this.position.x,
                    right: this.position.x + this.width,
                    top: this.position.y,
                    bottom: this.position.y + this.height
                };
            }
            
            collidesWith(other) {
                const a = this.getBounds();
                const b = other.getBounds();
                return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);
            }
        }
        
        class Player extends GameObject {
            constructor(x, y) {
                super(x, y, 40, 40);
                this.speed = 300;
                this.shootCooldown = 0;
                this.maxShootCooldown = 0.2;
                this.powerLevel = 1;
            }
            
            update(deltaTime, input) {
                this.velocity = new Vector2(0, 0);
                
                if (input.left && this.position.x > 0) {
                    this.velocity.x = -this.speed;
                }
                if (input.right && this.position.x < 800 - this.width) {
                    this.velocity.x = this.speed;
                }
                if (input.up && this.position.y > 0) {
                    this.velocity.y = -this.speed;
                }
                if (input.down && this.position.y < 600 - this.height) {
                    this.velocity.y = this.speed;
                }
                
                super.update(deltaTime);
                
                if (this.shootCooldown > 0) {
                    this.shootCooldown -= deltaTime;
                }
            }
            
            canShoot() {
                return this.shootCooldown <= 0;
            }
            
            shoot() {
                if (this.canShoot()) {
                    this.shootCooldown = this.maxShootCooldown;
                    const bullets = [];
                    
                    if (this.powerLevel >= 1) {
                        bullets.push(new Bullet(this.position.x + this.width/2 - 2, this.position.y, 0, -400));
                    }
                    if (this.powerLevel >= 2) {
                        bullets.push(new Bullet(this.position.x + 5, this.position.y, -50, -400));
                        bullets.push(new Bullet(this.position.x + this.width - 5, this.position.y, 50, -400));
                    }
                    if (this.powerLevel >= 3) {
                        bullets.push(new Bullet(this.position.x, this.position.y + 10, -100, -350));
                        bullets.push(new Bullet(this.position.x + this.width, this.position.y + 10, 100, -350));
                    }
                    
                    return bullets;
                }
                return [];
            }
            
            draw(ctx) {
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
                
                // Draw ship details
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.position.x + 15, this.position.y + 5, 10, 15);
                ctx.fillRect(this.position.x + 5, this.position.y + 25, 30, 10);
            }
        }
        
        class Enemy extends GameObject {
            constructor(x, y, type = 'basic') {
                super(x, y, 30, 30);
                this.type = type;
                this.health = type === 'boss' ? 5 : 1;
                this.maxHealth = this.health;
                this.shootTimer = Math.random() * 2;
                this.speed = type === 'boss' ? 50 : 100 + Math.random() * 100;
                this.velocity.y = this.speed;
                this.value = type === 'boss' ? 100 : 10;
                
                if (type === 'boss') {
                    this.width = 80;
                    this.height = 60;
                }
            }
            
            update(deltaTime) {
                super.update(deltaTime);
                this.shootTimer -= deltaTime;
                
                // Bounce off edges for boss
                if (this.type === 'boss') {
                    if (this.position.x <= 0 || this.position.x >= 800 - this.width) {
                        this.velocity.x *= -1;
                    }
                    this.velocity.x = this.velocity.x || (Math.random() > 0.5 ? 50 : -50);
                }
            }
            
            canShoot() {
                return this.shootTimer <= 0;
            }
            
            shoot() {
                if (this.canShoot()) {
                    this.shootTimer = 1 + Math.random() * 2;
                    return [new Bullet(this.position.x + this.width/2, this.position.y + this.height, 0, 200, false)];
                }
                return [];
            }
            
            takeDamage() {
                this.health--;
                return this.health <= 0;
            }
            
            draw(ctx) {
                const healthRatio = this.health / this.maxHealth;
                
                if (this.type === 'boss') {
                    ctx.fillStyle = `rgb(${255 - healthRatio * 100}, 50, 50)`;
                } else {
                    ctx.fillStyle = '#ff4444';
                }
                
                ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
                
                // Health bar for bosses
                if (this.type === 'boss') {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.position.x, this.position.y - 10, this.width, 5);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(this.position.x, this.position.y - 10, this.width * healthRatio, 5);
                }
            }
        }
        
        class Bullet extends GameObject {
            constructor(x, y, vx, vy, friendly = true) {
                super(x, y, 4, 8);
                this.velocity = new Vector2(vx, vy);
                this.friendly = friendly;
            }
            
            update(deltaTime) {
                super.update(deltaTime);
                
                if (this.position.y < -10 || this.position.y > 610 || 
                    this.position.x < -10 || this.position.x > 810) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                ctx.fillStyle = this.friendly ? '#ffff00' : '#ff8800';
                ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
            }
        }
        
        class PowerUp extends GameObject {
            constructor(x, y, type) {
                super(x, y, 20, 20);
                this.type = type; // 'weapon', 'life', 'score'
                this.velocity.y = 80;
                this.bobTimer = 0;
            }
            
            update(deltaTime) {
                super.update(deltaTime);
                this.bobTimer += deltaTime * 5;
                
                if (this.position.y > 600) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                const bob = Math.sin(this.bobTimer) * 2;
                
                switch (this.type) {
                    case 'weapon':
                        ctx.fillStyle = '#00ff00';
                        break;
                    case 'life':
                        ctx.fillStyle = '#ff00ff';
                        break;
                    case 'score':
                        ctx.fillStyle = '#ffff00';
                        break;
                }
                
                ctx.fillRect(this.position.x, this.position.y + bob, this.width, this.height);
            }
        }
        
        class ParticleEffect {
            constructor(x, y, color = '#ffff00') {
                this.particles = [];
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 200,
                        vy: (Math.random() - 0.5) * 200,
                        life: 1,
                        maxLife: 1,
                        color: color
                    });
                }
            }
            
            update(deltaTime) {
                this.particles.forEach(p => {
                    p.x += p.vx * deltaTime;
                    p.y += p.vy * deltaTime;
                    p.life -= deltaTime;
                });
                
                this.particles = this.particles.filter(p => p.life > 0);
            }
            
            draw(ctx) {
                this.particles.forEach(p => {
                    const alpha = p.life / p.maxLife;
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, 3, 3);
                    ctx.restore();
                });
            }
            
            isDead() {
                return this.particles.length === 0;
            }
        }
        
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameState = 'playing'; // 'playing', 'gameOver'
                
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.enemySpawnTimer = 0;
                this.levelTimer = 0;
                
                this.player = new Player(380, 500);
                this.enemies = [];
                this.bullets = [];
                this.powerUps = [];
                this.particles = [];
                
                this.input = {
                    left: false,
                    right: false,
                    up: false,
                    down: false,
                    shoot: false
                };
                
                this.lastTime = 0;
                this.setupInput();
                this.gameLoop();
            }
            
            setupInput() {
                document.addEventListener('keydown', (e) => {
                    switch(e.code) {
                        case 'ArrowLeft': this.input.left = true; break;
                        case 'ArrowRight': this.input.right = true; break;
                        case 'ArrowUp': this.input.up = true; break;
                        case 'ArrowDown': this.input.down = true; break;
                        case 'Space': 
                            this.input.shoot = true; 
                            e.preventDefault(); 
                            break;
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    switch(e.code) {
                        case 'ArrowLeft': this.input.left = false; break;
                        case 'ArrowRight': this.input.right = false; break;
                        case 'ArrowUp': this.input.up = false; break;
                        case 'ArrowDown': this.input.down = false; break;
                        case 'Space': this.input.shoot = false; break;
                    }
                });
            }
            
            gameLoop(currentTime = 0) {
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;
                
                if (this.gameState === 'playing') {
                    this.update(deltaTime);
                }
                this.draw();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            update(deltaTime) {
                // Update player
                this.player.update(deltaTime, this.input);
                
                // Player shooting
                if (this.input.shoot) {
                    const newBullets = this.player.shoot();
                    this.bullets.push(...newBullets);
                }
                
                // Spawn enemies
                this.enemySpawnTimer -= deltaTime;
                if (this.enemySpawnTimer <= 0) {
                    this.spawnEnemy();
                    this.enemySpawnTimer = Math.max(0.5, 2 - this.level * 0.1);
                }
                
                // Update enemies
                this.enemies.forEach(enemy => {
                    enemy.update(deltaTime);
                    
                    // Enemy shooting
                    if (Math.random() < 0.01) {
                        const enemyBullets = enemy.shoot();
                        this.bullets.push(...enemyBullets);
                    }
                });
                
                // Update bullets
                this.bullets.forEach(bullet => bullet.update(deltaTime));
                
                // Update power-ups
                this.powerUps.forEach(powerUp => powerUp.update(deltaTime));
                
                // Update particles
                this.particles.forEach(effect => effect.update(deltaTime));
                
                // Collision detection
                this.handleCollisions();
                
                // Clean up inactive objects
                this.bullets = this.bullets.filter(bullet => bullet.active);
                this.enemies = this.enemies.filter(enemy => enemy.active);
                this.powerUps = this.powerUps.filter(powerUp => powerUp.active);
                this.particles = this.particles.filter(effect => !effect.isDead());
                
                // Level progression
                this.levelTimer += deltaTime;
                if (this.levelTimer > 30) {
                    this.level++;
                    this.levelTimer = 0;
                }
                
                // Update UI
                this.updateUI();
            }
            
            spawnEnemy() {
                const x = Math.random() * (800 - 30);
                const isBoss = this.level % 5 === 0 && Math.random() < 0.3;
                this.enemies.push(new Enemy(x, -30, isBoss ? 'boss' : 'basic'));
            }
            
            handleCollisions() {
                // Bullets vs enemies
                this.bullets.forEach(bullet => {
                    if (!bullet.friendly) return;
                    
                    this.enemies.forEach(enemy => {
                        if (bullet.collidesWith(enemy)) {
                            bullet.active = false;
                            if (enemy.takeDamage()) {
                                enemy.active = false;
                                this.score += enemy.value;
                                this.particles.push(new ParticleEffect(enemy.position.x + enemy.width/2, enemy.position.y + enemy.height/2, '#ff4444'));
                                
                                // Spawn power-up occasionally
                                if (Math.random() < 0.3) {
                                    this.spawnPowerUp(enemy.position.x + enemy.width/2, enemy.position.y + enemy.height/2);
                                }
                            }
                        }
                    });
                });
                
                // Enemy bullets vs player
                this.bullets.forEach(bullet => {
                    if (bullet.friendly) return;
                    
                    if (bullet.collidesWith(this.player)) {
                        bullet.active = false;
                        this.lives--;
                        this.particles.push(new ParticleEffect(this.player.position.x + this.player.width/2, this.player.position.y + this.player.height/2, '#00ffff'));
                        
                        if (this.lives <= 0) {
                            this.gameOver();
                        }
                    }
                });
                
                // Enemies vs player
                this.enemies.forEach(enemy => {
                    if (enemy.collidesWith(this.player)) {
                        enemy.active = false;
                        this.lives--;
                        this.particles.push(new ParticleEffect(this.player.position.x + this.player.width/2, this.player.position.y + this.player.height/2, '#00ffff'));
                        
                        if (this.lives <= 0) {
                            this.gameOver();
                        }
                    }
                });
                
                // Power-ups vs player
                this.powerUps.forEach(powerUp => {
                    if (powerUp.collidesWith(this.player)) {
                        powerUp.active = false;
                        this.applyPowerUp(powerUp.type);
                        this.particles.push(new ParticleEffect(powerUp.position.x + powerUp.width/2, powerUp.position.y + powerUp.height/2, '#00ff00'));
                    }
                });
            }
            
            spawnPowerUp(x, y) {
                const types = ['weapon', 'life', 'score'];
                const type = types[Math.floor(Math.random() * types.length)];
                this.powerUps.push(new PowerUp(x - 10, y, type));
            }
            
            applyPowerUp(type) {
                switch(type) {
                    case 'weapon':
                        this.player.powerLevel = Math.min(3, this.player.powerLevel + 1);
                        break;
                    case 'life':
                        this.lives++;
                        break;
                    case 'score':
                        this.score += 50;
                        break;
                }
            }
            
            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#000011';
                this.ctx.fillRect(0, 0, 800, 600);
                
                // Draw stars
                this.drawStars();
                
                if (this.gameState === 'playing') {
                    // Draw game objects
                    this.player.draw(this.ctx);
                    this.enemies.forEach(enemy => enemy.draw(this.ctx));
                    this.bullets.forEach(bullet => bullet.draw(this.ctx));
                    this.powerUps.forEach(powerUp => powerUp.draw(this.ctx));
                    this.particles.forEach(effect => effect.draw(this.ctx));
                }
            }
            
            drawStars() {
                this.ctx.fillStyle = '#ffffff';
                for (let i = 0; i < 50; i++) {
                    const x = (i * 37) % 800;
                    const y = (i * 23 + Date.now() * 0.01) % 600;
                    this.ctx.fillRect(x, y, 1, 1);
                }
            }
            
            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('level').textContent = this.level;
            }
            
            gameOver() {
                this.gameState = 'gameOver';
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            restart() {
                this.gameState = 'playing';
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.enemySpawnTimer = 0;
                this.levelTimer = 0;
                
                this.player = new Player(380, 500);
                this.enemies = [];
                this.bullets = [];
                this.powerUps = [];
                this.particles = [];
                
                document.getElementById('gameOver').style.display = 'none';
                this.updateUI();
            }
        }
        
        // Start the game
        const game = new Game();
    </script>
</body>
</html>